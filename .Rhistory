}
#calculate heterozygosity values for generated genotypes - NOTE this is across nSNPs only
het <- matrix(nrow=nrow(popgen), ncol=1)
for(g in 1:nrow(popgen)){
w <- sum(popgen[g ,seq(1,ncol(popgen),2)]!=popgen[g,seq(2,ncol(popgen),2)])/(ncol(popgen)/2)   #add up number of hetero sites per number of SNPs
het[g,1] <- w
}
pop[,11] <- het  #fill in calculated heterozygosities in the pop matrix
# #create migrant and nonmigrant unique SNPs - will be used to follow migrant ancestry
popSNPs = matrix(nrow=k, ncol=nSNP.mig*2)
columnsb = seq(1,(nSNP.mig*2),2)
for(b in 1:nrow(popSNPs)){    #set up similar to above in case change the sequence or format later
popSNPs[b,] = 0             #all focal pop indv have nSNP.mig = 0
}
#REMOVE##focalpop <- cbind(pop, popgen, popSNPs, conSNPs)   ##use this when generating all 3 types of SNPs
focalpop <- cbind(pop, popgen, popSNPs)
pop <- focalpop
#clean up
remove(popgen, popSNPs, het, b, g, w, columns, columnsb, gtype, kk, l, pool) #focalpop, conSNPs
#initialize source population
source = matrix(nrow=s, ncol=13)            #each individual gets its own row.
colnames(source) <- c("id", "mom", "dad", "age", "sex", "n offspring", "n adult offspring", "alive", "gen born", "gen died", "relative fitness", "prop migrant SNPs", "subgroup") #just to give a better understanding of what these variables are, set names
#initialize source population
source = matrix(nrow=k, ncol=13)            #each individual gets its own row.
colnames(source) <- c("id", "mom", "dad", "age", "sex", "n offspring", "n adult offspring", "alive", "gen born", "gen died", "relative fitness", "prop migrant SNPs", "subgroup") #just to give a better understanding of what these variables are, set names
source[,1] = seq(-(s),-1,1)                 #each individual has unique ID name; sequence starting at -1, through -k, with each 1 iteration, negative flag for source pop
#initialize source population
source = matrix(nrow=k, ncol=13)            #each individual gets its own row.
colnames(source) <- c("id", "mom", "dad", "age", "sex", "n offspring", "n adult offspring", "alive", "gen born", "gen died", "relative fitness", "prop migrant SNPs", "subgroup") #just to give a better understanding of what these variables are, set names
source[,1] = seq(-(k),-1,1)                 #each individual has unique ID name; sequence starting at -1, through -k, with each 1 iteration, negative flag for source pop
source[,2:3] = -1                           #at this point, we are putting all equal to negative 1 to flag from source pop, and we dont know parents because parents arent in focal pop
source[,4] = sample(seq(0,maxage,1),s,replace=T)   #set age between 0 and maxage (source isnt aged, so dont subtract 1)
source[,5] = sample(c(0,1),k,replace=T)     #each individual assigned male (1) or female (0)
source[,2:3] = -1                           #at this point, we are putting all equal to negative 1 to flag from source pop, and we dont know parents because parents arent in focal pop
source[,4] = sample(seq(0,maxage,1),k,replace=T)   #set age between 0 and maxage (source isnt aged, so dont subtract 1)
source[,5] = sample(c(0,1),k,replace=T)     #each individual assigned male (1) or female (0)
source[,6] = NA                             #this will be for number of times as a parent
source[,7] = NA                             #for number of offspring that reach maturity
source[,8] = 1                              #alive or dead? alive = 1, dead = 0
source[,9] = -1                             #generation born - will be changed in Migrate.R to the generation entered focal pop
source[,10] = 0                             #generation died
source[,11] = NA                            #relative fitness, aka heterozygosity *of nSNP only* - calculated below
source[,12] = 0                             #proportion of migrant SNPs - initial source pop will all be 1
source[,13] = sample(c("E","W"), k, replace=T) #assigns indvs as East of West subgroups? this should be something I can change
sz = k                                   #to keep track of the number of indv for ID'ing later
sz_col = ncol(pop)
#generate source gentoypes
sourcegen = matrix(nrow=s, ncol=nSNP*2)
columns = seq(1,(nSNP*2),2)  #create 2 columns per SNP with 0-1 for each allele
#generate source gentoypes
sourcegen = matrix(nrow=k, ncol=nSNP*2) #this is where s was too instead of k
columns = seq(1,(nSNP*2),2)  #create 2 columns per SNP with 0-1 for each allele
for(l in 1:nSNP){
p = sample(seq(from=LBhet, to=(LBhet+0.1), by=0.01), 1)  #introduce variation by selecting p, range defined in Cover.R
#create pool of genotypes in HWE
pool = c(rep(0, round(s*p*p, 0)),                                      #homozygous p*p
rep(1, round(s*(1-p)*(1-p), 0)),                              #homozygous (1-p)*(1-p)
rep(2, s-(round(s*p*p, 0)+(round(s*(1-p)*(1-p), 0))))         #heterozygous
)
#connect pool to indvs and assign the genotypes
gtype = sample(pool, s, replace = FALSE)
for(ss in 1:s){
if(gtype[ss]==0){                 #homo (0,0)
sourcegen[ss,columns[l]]   = 0
sourcegen[ss,columns[l]+1] = 0
next
}else if(gtype[ss]==2){           #hetero (0,1)
sourcegen[ss,columns[l]]   = 0
sourcegen[ss,columns[l]+1] = 1
}else{                            #homo (1,1)
sourcegen[ss,columns[l]]   = 1
sourcegen[ss,columns[l]+1] = 1
}
}
}
AgeUp = function(pop){
dead = pop[pop[,9] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(pop))){
pop[,2] = pop[,2] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop<- rbind(pop,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(pop)
}
AgeUp = function(pop, source){
dead = pop[pop[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(pop))){
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop<- rbind(pop,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(pop)
dead = source[source[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
source = source[-which(source[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(source))){
source[,4] = source[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
source<- rbind(source,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(source)
}
dead = pop[pop[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(pop))){
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
class(pop[, 4])
maturity.V    = 2             #age indv becomes reproductively mature
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
.
if (is.numeric(pop[, 4])) {
pop[, 4] <- as.numeric(pop[, 4])
}
if(!is.null(nrow(pop))){
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
if(!is.numeric(pop[, 4])) {
pop[, 4] <- as.numeric(pop[, 4])
}
if(!is.null(nrow(pop))){
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop[,4] = rpois(k,2)-1            #set age with a poisson distribution around the age of maturity (although i had to change to a numner 2 since maturity was giving me errors) and subtract 1 because we age as the first step in the simulation   #FOR UNIFORM DIST: dunif(k, min =0, max = maturity, log = FALSE)-1  #FOR RANDOM DIST: sample(seq(0,maxage,1),k,replace=T)-1
dead = pop[pop[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(pop))){
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop[,4] = rpois(k,maturity)-1            #set age with a poisson distribution around the age of maturity (although i had to change to a numner 2 since maturity was giving me errors) and subtract 1 because we age as the first step in the simulation   #FOR UNIFORM DIST: dunif(k, min =0, max = maturity, log = FALSE)-1  #FOR RANDOM DIST: sample(seq(0,maxage,1),k,replace=T)-1
if(!is.null(nrow(pop))){
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
if(!is.null(nrow(pop))){
pop[,4] = pop[,4] + 1
if(!is.null(nrow(pop))){
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
if(!is.null(nrow(pop))){
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(pop))){
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop
rpois(k,maturity)-1
#add one year to all live indv's ages this is a two in RunModel.R
pop[,4] = rpois(k,maturity)-1            #set age with a poisson distribution around the age of maturity (although i had to change to a numner 2 since maturity was giving me errors) and subtract 1 because we age as the first step in the simulation   #FOR UNIFORM DIST: dunif(k, min =0, max = maturity, log = FALSE)-1  #FOR RANDOM DIST: sample(seq(0,maxage,1),k,replace=T)-1
po
pop
pop[,4] + 1
pop[,4]
as.numeric(pop[,4])
as.numeric(pop[,4]) + 1
if(!is.null(nrow(pop))){
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop[,4] = as.numeric(rpois(k,maturity) - 1)            #set age with a poisson distribution around the age of maturity (although i had to change to a numner 2 since maturity was giving me errors) and subtract 1 because we age as the first step in the simulation   #FOR UNIFORM DIST: dunif(k, min =0, max = maturity, log = FALSE)-1  #FOR RANDOM DIST: sample(seq(0,maxage,1),k,replace=T)-1
pop
pop[,4] = pop[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
pop[,4] = rpois(k,maturity) - 1         #set age with a poisson distribution around the age of maturity (although i had to change to a numner 2 since maturity was giving me errors) and subtract 1 because we age as the first step in the simulation   #FOR UNIFORM DIST: dunif(k, min =0, max = maturity, log = FALSE)-1  #FOR RANDOM DIST: sample(seq(0,maxage,1),k,replace=T)-1
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
pop
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
pop
source("~/GitHub/CaribouPopGen/Source/AgeUp.R")
source("~/GitHub/CaribouPopGen/Source/AgeUp.R")
source("~/GitHub/CaribouPopGen/Source/AgeUp.R")
source("~/GitHub/CaribouPopGen/Source/AgeUp.R")
AgeUp = function(pop, source){
dead = pop[pop[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
# if(!is.numeric(pop[, 4])) {
#   pop[, 4] <- as.numeric(pop[, 4])
# }
if(!is.null(nrow(pop))){
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop<- rbind(pop,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(pop)
dead = source[source[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
source = source[-which(source[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(source))){
source[,4] = source[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
source<- rbind(source,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(source)
}
dead = pop[pop[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(pop))){
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop<- rbind(pop,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(pop)
return(pop)
AgeUp = function(pop, source){
dead = pop[pop[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
# if(!is.numeric(pop[, 4])) {
#   pop[, 4] <- as.numeric(pop[, 4])
# }
if(!is.null(nrow(pop))){                                           #I added as numeric because it was giving me this error: Error in pop[, 4] + 1 : non-numeric argument to binary operator
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop<- rbind(pop,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(pop)
}
AgeUp = function(pop, source){
dead = pop[pop[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
# if(!is.numeric(pop[, 4])) {
#   pop[, 4] <- as.numeric(pop[, 4])
# }
if(!is.null(nrow(pop))){                                           #I added as numeric because it was giving me this error: Error in pop[, 4] + 1 : non-numeric argument to binary operator
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop<- rbind(pop,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(pop)
}
dead = source[source[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
source = source[-which(source[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(source))){
source[,4] = source[,4] + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
source[,4] = as.numeric(source[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
if(!is.null(nrow(source))){
source[,4] = as.numeric(source[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
source<- rbind(source,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(source)
#this will impose an increased in probability of death with increasing age AND kill indv over the maxage
AgeDeath = function(pop, maxage, y){
dead = pop[pop[,8] == 0, , drop=FALSE]          #remove dead indvs
pop = pop[pop[,8] == 1, , drop=FALSE]                  #isolate alive
babes = pop[pop[,4] == 0, , drop=FALSE]      #remove babies from chance of dying
pop = pop[pop[,4] != 0, , drop=FALSE]      #isolate those that are not newly generated babies
if(nrow(pop) > 1){
for(ee in 1:nrow(pop)){
age = pop[ee,4] #+0.000001 #this controls for if age = 0 in source migrants in that generation
pop[ee,8] = sample(x=c(0,1), size = 1, replace = TRUE, prob = c(age/maxage,(1-(age/maxage))))
if(pop[ee,8]==0){
pop[ee,10] = y    #this is to put year died if I create that column
}
}
nkilled = NULL
nkilled = pop[pop[,8]==0,,drop=FALSE]
totalkilled = nrow(nkilled)   #consider if you want to track this for Analyze.R
print(paste("killed", totalkilled, "individuals"))
}else{
print(paste("no killing in AgeDeath"))
}
#combine pop and previously removed dead indv
pop = rbind(pop, babes, dead)
#if(nrow(alreadydead) >= 1){
#pop = rbind(pop,alreadydead)
#}
remove(babes, dead, nkilled, totalkilled, age)
return(pop)
}
dead = pop[pop[,8] == 0, , drop=FALSE]          #remove dead indvs
pop = pop[pop[,8] == 1, , drop=FALSE]                  #isolate alive
babes = pop[pop[,4] == 0, , drop=FALSE]      #remove babies from chance of dying
pop = pop[pop[,4] != 0, , drop=FALSE]      #isolate those that are not newly generated babies
if(nrow(pop) > 1){
for(ee in 1:nrow(pop)){
age = pop[ee,4] #+0.000001 #this controls for if age = 0 in source migrants in that generation
pop[ee,8] = sample(x=c(0,1), size = 1, replace = TRUE, prob = c(age/maxage,(1-(age/maxage))))
if(pop[ee,8]==0){
pop[ee,10] = y    #this is to put year died if I create that column
}
}
nkilled = NULL
nkilled = pop[pop[,8]==0,,drop=FALSE]
totalkilled = nrow(nkilled)   #consider if you want to track this for Analyze.R
print(paste("killed", totalkilled, "individuals"))
}else{
print(paste("no killing in AgeDeath"))
}
for(ee in 1:nrow(pop)){
age = pop[ee,4] #+0.000001 #this controls for if age = 0 in source migrants in that generation
pop[ee,8] = sample(x=c(0,1), size = 1, replace = TRUE, prob = c(age/maxage,(1-(age/maxage))))
if(pop[ee,8]==0){
pop[ee,10] = y    #this is to put year died if I create that column
}
}
nkilled = NULL
nkilled = pop[pop[,8]==0,,drop=FALSE]
totalkilled = nrow(nkilled)   #consider if you want to track this for Analyze.R
print(paste("killed", totalkilled, "individuals"))
if(nrow(pop) > 1){
for(ee in 1:nrow(pop)){
age = pop[ee,4] #+0.000001 #this controls for if age = 0 in source migrants in that generation
pop[ee,8] = sample(x=c(0,1), size = 1, replace = TRUE, prob = c(age/maxage,(1-(age/maxage))))
if(pop[ee,8]==0){
pop[ee,10] = y    #this is to put year died if I create that column
}
}
nkilled = NULL
nkilled = pop[pop[,8]==0,,drop=FALSE]
totalkilled = nrow(nkilled)   #consider if you want to track this for Analyze.R
print(paste("killed", totalkilled, "individuals"))
}else{
print(paste("no killing in AgeDeath"))
}
#combine pop and previously removed dead indv
pop = rbind(pop, babes, dead)
remove(babes, dead, nkilled, totalkilled, age)
return(pop)
#new parameters:
styr          = 100 #year to start pop for stabilizing
PopSizeNext = function(pop, k, r0, maturity, y, styr, parameters, r, K){
dead = pop[pop[,8] == 0, , drop=FALSE]                 #remove dead indv
alive = pop[which(pop[,1]%NOTin%dead), , drop = FALSE]
#since only returning numboff, dont need to rbind dead and alive into pop
#pop = pop[pop[,4] >= maturity, , drop=FALSE]          #isolate adults -- if only want effective pop size to count here
#if only using adults, remove immature
#calculate the current population size following aging and death
###REMOVED# Nt = nrow(pop) #use this if removing dead from pop
Nt = nrow(alive)
if(y < styr){               #maintain k for the burn in period
K = k
R0 = r0
# }else if(y > edyr + dur){
#   deltaK = abs(round((k - nwk)/(styr - edyr)))
#   K = K + deltaK
#   R0 = r0
if(K > parameters$k[r]){  #check to make sure K is not greater than the original k in Cover.R
K <- parameters$k[r]
}
# }else if(styr <= y & y < edyr){ #change K to push pop into bottleneck
#   deltaK = round(abs(k - nwk)/(styr - edyr)) #this is the change in K per year for the decline period
#   #note, deltaK will be negative when pop is decreasing
#
#   K = K + deltaK
#
# }else{                       #if during the duration period of bottleneck, maintain small pop size
#   K = nwk
#   R0 = r0/2    #introduce allee effect, but only at lowest pop size
}
#calculate the new pop size with the logistic growth equation
Ntt = Nt*(1+R0*(1-(Nt/K))) #logistic
#r0 is the per capita growth rate, set as a parameter in Cover.R
#add Density Independent variance in growth
Nt1 = round(rnorm(1, Ntt, 1), 0)
Nt1 = as.integer(Nt1)
print(paste("The next generation's population size will be", Nt1, "K is", K, "k is", k))
#determine the number of additional offspring to produce
numboff = Nt1 - Nt
#for some reason numboff is a double and causing problems
#turn numboff into an integer
numboff = as.integer(numboff)
print(paste("the number of offspring needed is", numboff))
remove(alive, dead)
return(list(numboff,K))
}
dead = pop[pop[,8] == 0, , drop=FALSE]                 #remove dead indv
alive = pop[which(pop[,1]%NOTin%dead), , drop = FALSE]
#calculate the current population size following aging and death
###REMOVED# Nt = nrow(pop) #use this if removing dead from pop
Nt = nrow(alive)
if(y < styr){               #maintain k for the burn in period
K = k
R0 = r0
# }else if(y > edyr + dur){
#   deltaK = abs(round((k - nwk)/(styr - edyr)))
#   K = K + deltaK
#   R0 = r0
if(K > parameters$k[r]){  #check to make sure K is not greater than the original k in Cover.R
K <- parameters$k[r]
}
# }else if(styr <= y & y < edyr){ #change K to push pop into bottleneck
#   deltaK = round(abs(k - nwk)/(styr - edyr)) #this is the change in K per year for the decline period
#   #note, deltaK will be negative when pop is decreasing
#
#   K = K + deltaK
#
# }else{                       #if during the duration period of bottleneck, maintain small pop size
#   K = nwk
#   R0 = r0/2    #introduce allee effect, but only at lowest pop size
}
K = k
R0 = r0
if(K > parameters$k[r]){  #check to make sure K is not greater than the original k in Cover.R
K <- parameters$k[r]
}
#calculate the new pop size with the logistic growth equation
Ntt = Nt*(1+R0*(1-(Nt/K))) #logistic
#add Density Independent variance in growth
Nt1 = round(rnorm(1, Ntt, 1), 0)
Nt1 = as.integer(Nt1)
print(paste("The next generation's population size will be", Nt1, "K is", K, "k is", k))
#determine the number of additional offspring to produce
numboff = Nt1 - Nt
#for some reason numboff is a double and causing problems
#turn numboff into an integer
numboff = as.integer(numboff)
print(paste("the number of offspring needed is", numboff))
remove(alive, dead)
return(list(numboff,K))
if(!is.null(nrow(pop))){                                           #I added as numeric because it was giving me this error: Error in pop[, 4] + 1 : non-numeric argument to binary operator
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
if(!is.null(nrow(source))){
source[,4] = (source[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
head(source)
AgeUp = function(pop, source){
dead = pop[pop[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
# if(!is.numeric(pop[, 4])) {
#   pop[, 4] <- as.numeric(pop[, 4])
# }
if(!is.null(nrow(pop))){                                           #I added as numeric because it was giving me this error: Error in pop[, 4] + 1 : non-numeric argument to binary operator
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop<- rbind(pop,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(pop)
}
dead = pop[pop[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(pop))){                                           #I added as numeric because it was giving me this error: Error in pop[, 4] + 1 : non-numeric argument to binary operator
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop<- rbind(pop,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(pop)
AgeUp = function(pop, source){
dead = pop[pop[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
pop = pop[-which(pop[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
# if(!is.numeric(pop[, 4])) {
#   pop[, 4] <- as.numeric(pop[, 4])
# }
if(!is.null(nrow(pop))){                                           #I added as numeric because it was giving me this error: Error in pop[, 4] + 1 : non-numeric argument to binary operator
pop[,4] = as.numeric(pop[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
pop<- rbind(pop,dead)                                  #recall dead indvs
remove(dead)                                           #clean up
return(pop)
}
deads = source[source[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(dead)>= 1){
source = source[-which(source[,1]%in%dead), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(source))){
source[,4] = (source[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
deadS = source[source[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(deadS)>= 1){
source = source[-which(source[,1]%in%deadS), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(source))){
source[,4] = (source[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
source<- rbind(source,deadS)                                  #recall dead indvs
remove(deadS)                                           #clean up
return(source)                                         #error at this point: Error: no function to return from, jumping to top level
if(!is.null(nrow(source))){
source[,4] = as.numeric(source[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
source<- rbind(source,deadS)                                  #recall dead indvs
deadS = source[source[,8] == 0, , drop=FALSE]                 #define dead indvs use the "alive" parameter in RunModel.R
if(nrow(deadS)>= 1){
source = source[-which(source[,1]%in%deadS), , drop=FALSE]     #remove dead indvs
}
if(!is.null(nrow(source))){
source[,4] = as.numeric(source[,4]) + 1                                #add one year to all live indv's ages this is a two in RunModel.R
}
source<- rbind(source,deadS)                                  #recall dead indvs
remove(deadS)                                           #clean up
return(source)                                         #error at this point: Error: no function to return from, jumping to top level
source("~/GitHub/CaribouPopGen/Breed.R")
source("~/GitHub/CaribouPopGen/Breed.R")
