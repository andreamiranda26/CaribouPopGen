# columnsb = seq(1,(nSNP.mig*2),2)
# for(b in 1:nrow(popSNPs)){    #set up similar to above in case change the sequence or format later
#   popSNPs[b,] = 0             #all focal pop indv have nSNP.mig = 0
}
#REMOVE###create conserved SNPs - will be used to follow mutation
#REMOVE##conSNPs = matrix(nrow=k, ncol=nSNP.cons*2)
#REMOVE##columnsc = seq(1,(nSNP.cons*2),2)
#REMOVE##for(c in 1:nrow(conSNPs)){    #set up similar to above in case change the sequence or format later
#REMOVE##  conSNPs[c,] = 0    #all indv of the species have nSNP.cons = 0
#REMOVE##}
#REMOVE##focalpop <- cbind(pop, popgen, popSNPs, conSNPs)   ##use this when generating all 3 types of SNPs
focalpop <- cbind(pop, popgen, popSNPs)
pop <- focalpop
#write starting pop to table
####REMOVED### write.table(pop, paste(directory, "/Output/focal_population", r, ".csv", sep=""), sep=",", col.names=T, row.names=F)
#clean up
remove(popgen, popSNPs, het, b, g, w, columns, columnsb, gtype, kk, l, pool) #focalpop, conSNPs
########################################################
### SOURCE POP
#initialize source population
source = matrix(nrow=s, ncol=12)            #each individual gets its own row.
colnames(source) <- c("id", "mom", "dad", "age", "sex", "n offspring", "n adult offspring", "alive", "gen born", "gen died", "relative fitness", "prop migrant SNPs") #just to give a better understanding of what these variables are, set names
source[,1] = seq(-(s),-1,1)                 #each individual has unique ID name; sequence starting at -1, through -k, with each 1 iteration, negative flag for source pop
source[,2:3] = -1                           #at this point, we are putting all equal to negative 1 to flag from source pop, and we dont know parents because parents arent in focal pop
source[,4] = sample(seq(0,maxage,1),s,replace=T)   #set age between 0 and maxage (source isnt aged, so dont subtract 1)
source[,5] = sample(c(0,1),s,replace=T)     #each individual assigned male (1) or female (0)
source[,6] = NA                             #this will be for number of times as a parent
source[,7] = NA                             #for number of offspring that reach maturity
source[,8] = 1                              #alive or dead? alive = 1, dead = 0
source[,9] = -1                             #generation born - will be changed in Migrate.R to the generation entered focal pop
source[,10] = 0                             #generation died
source[,11] = NA                            #relative fitness, aka heterozygosity *of nSNP only* - calculated below
source[,12] = 1                             #proportion of migrant SNPs - initial source pop will all be 1
#generate source gentoypes
sourcegen = matrix(nrow=s, ncol=nSNP*2)
columns = seq(1,(nSNP*2),2)  #create 2 columns per SNP with 0-1 for each allele
for(l in 1:nSNP){
p = sample(seq(from=LBhet, to=(LBhet+0.1), by=0.01), 1)  #introduce variation by selecting p, range defined in Cover.R
#create pool of genotypes in HWE
pool = c(rep(0, round(s*p*p, 0)),                                      #homozygous p*p
rep(1, round(s*(1-p)*(1-p), 0)),                              #homozygous (1-p)*(1-p)
rep(2, s-(round(s*p*p, 0)+(round(s*(1-p)*(1-p), 0))))         #heterozygous
)
#connect pool to indvs and assign the genotypes
gtype = sample(pool, s, replace = FALSE)
for(ss in 1:s){
if(gtype[ss]==0){                 #homo (0,0)
sourcegen[ss,columns[l]]   = 0
sourcegen[ss,columns[l]+1] = 0
next
}else if(gtype[ss]==2){           #hetero (0,1)
sourcegen[ss,columns[l]]   = 0
sourcegen[ss,columns[l]+1] = 1
}else{                            #homo (1,1)
sourcegen[ss,columns[l]]   = 1
sourcegen[ss,columns[l]+1] = 1
}
}
}
#calculate heterozygosity values for generated genotypes - NOTE this is across nSNPs only
sourcehet <- matrix(nrow=nrow(sourcegen), ncol=1)
for(j in 1:nrow(sourcegen)){
z <- sum(sourcegen[j ,seq(1,ncol(sourcegen),2)]!=sourcegen[j,seq(2,ncol(sourcegen),2)])/(ncol(sourcegen)/2)  #add up number of hetero sites per number of SNPs
sourcehet[j,1] <- z
}
source[,11] <- sourcehet  #fill in calculated heterozygosities in the source matrix
#create migrant and nonmigrant unique SNPs - used to track migrant ancestry
migSNPs = matrix(nrow=s, ncol=nSNP.mig*2)
columnsd= seq(1,(nSNP.mig*2),2)
for(d in 1:nrow(migSNPs)){    #set up similar to above in case change the sequence or format later
migSNPs[d,] = 1              #all source pop indv have nSNP.mig = 1
}
#REMOVE###create conserved SNPs - used to track mutation
#REMOVE##conSNPs = matrix(nrow=s, ncol=nSNP.cons*2)
#REMOVE##columnse = seq(1,(nSNP.cons*2),2)
#REMOVE##for(e in 1:nrow(conSNPs)){    #set up similar to above in case change the sequence or format later
#REMOVE##  conSNPs[e,] = 0             #all indv of the species have nSNP.cons = 0
#REMOVE##}
#REMOVE##source1 <- cbind(source, sourcegen, migSNPs, conSNPs)   ##use this when generating all 3 types of SNPs
source1 <- cbind(source, sourcegen, migSNPs)
source <- source1
#write starting source to table
###REMOVED### write.table(source, paste(directory, "/Output/source", r, ".csv", sep=""), sep=",", col.names=T, row.names=F)
#prepare focal and source pop for Fst analysis in hierfstat (enacted in Analyze.R)
SNPS = (nSNP*2) + (nSNP.mig*2) + (nSNP.cons*2)                                #find number of SNPs
pos1 = seq(1, SNPS, 2)                                                        #allele 1 positions, aka odd values
pos2 = pos1+1                                                                 #allele 2 positions, aka even values
fstinit <- focalpop[, -c(ncol(focalpop)-(SNPS):ncol(focalpop))]               #grab SNPs
fstinit[fstinit[,]==0] <-2                                                    #change 0s to 2s
fstinit[,pos1] <- as.numeric(paste(fstinit[,pos1], fstinit[,pos2], sep=""))   #merge SNPs
fstinit <- fstinit[,-c(pos2)]                                                 #remove single pos2 SNPs
initident <- matrix(nrow=nrow(fstinit), ncol=1)                               #add pop identifier
initident[,1] = 0                                                             #define initialized focal pop
fstinit <- cbind(initident,fstinit)                                           #merge identifier and genotypes
fstsource <- source1[, -c(ncol(source1)-(SNPS):ncol(source1))]                    #grab SNPs
fstsource[fstsource[,]==0] <-2                                                    #change 0s to 2s
fstsource[,pos1] <- as.numeric(paste(fstsource[,pos1], fstsource[,pos2], sep="")) #merge SNPs
fstsource <- fstsource[,-c(pos2)]                                                 #remove single pos2 SNPs
sourceident <- matrix(nrow=nrow(fstsource), ncol=1)                               #add pop identifier
sourceident[,1] = -1                                                              #define initialized source pop
fstsource <- cbind(sourceident,fstsource)                                         #merge identifier and genotypes
#clean up
remove(source1, focalpop, initident, sourceident, sourcegen, pool, migSNPs, l, d, ss, sourcehet, gtype, columns, columnsd, z, j) #currently holding p if needed
#REMOVE##remove(conSNPs, columnsc,  columnse, c)  #use this if nSNP.cons != 0
#create for loop for each time step
for(y in 0:years){
if(y != 0){
pop = AgeUp(pop)                        #age pop + 1 year
#pop = FitnessDeath(pop, maturity, y)    #kill indv
#REMOVE##pop = DeathByAge(pop, maxage)          #age-dependent mortality
# if(sum(pop[,8]) <= 10){                 #if there are <=10 indv, crash pop
#   print(paste("Crash @ FitnessDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
FINAL = rbind(FINAL, out[1,])
break
}
#REMOVE##tttt = Stochastic(pop, stoch, k, numboff, styr, edyr, nwk, dur, y, years, r0, parameters, r)  #function for stochastic decline in pop
#REMOVE##pop = tttt[[1]]
#REMOVE##k = tttt[[2]]
#REMOVE##pop = RandomDeath(pop)                  #random mortality
tt = Migrate(pop, source, y, miggy, styr, edyr, dur)        #subpop migration from source to focal
pop = tt[[1]]  #output 1 is the pop object
mig = tt[[2]]  #output 2 is the number of migrants
sz = sz + mig  #used for tracking number of indv and their ID numbers
source = tt[[3]] #output 3 is the source object
# if(sum(pop[,8]) <= 4){                #if there are <=4 indv, crash pop
#print(paste("Population crash @ MateChoice, less than 4 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
FINAL = rbind(FINAL, out[1,])
break
}
pairs = MateChoice(pop, sex, maturity)  #choose mates, Gina had also added allee, matemigs in there , now its same as MateChoice.R
if(is.null(pairs)==TRUE){    #if there are no mates, pop crashes
print(paste("skipping pop size next, breed due to no parents"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
FINAL = rbind(FINAL, out[1,])
break  #break out of this loop
}
pp = PopSizeNext(pop, k, r0, maturity, y, styr, edyr, nwk, dur, parameters, r, K) #calculate the next generation's pop size according to logistic growth eqn
numboff = pp[[1]]  #output 1 is the number of offspring to produce
K = pp[[2]]        #output 2 is the new K (carrying capacity)
if(numboff >= 1){
ttt = Breed(pop, pairs, numboff, k, sz, nSNP, nSNP.mig, broodsize, y, mu, mutate, nSNP.cons, pos1, pos2, rr, r, prj, grp, matemigs) #create new babies!
pop = ttt[[1]]   #output 1 is the new pop object
bb = ttt[[2]]    #output 2 is the number of babies added
sz = sz + bb     #for tracking number of indv for IDing
}else if(numboff <= 0){
print(paste("No new babies, skip breed"))
#still fill out Ne count table
{
NE = matrix(nrow=1, ncol=12)   #create matrix for Ne Count table
colnames(NE) <- c("year", "eff_mom", "eff_dad", "nbabies", "naliveadults", "possible_mom", "possible_dad", "eff_mig", "parameterset", "replicate", "project", "group") #just to give a better understanding of what these variables are, set names
NE[1,1] = y                             #grab year
NE[1,2] = 0                             #grab n unique effective moms
NE[1,3] = 0                             #grab n unique effective dads
NE[1,4] = 0                             #grab n babies
alive = pop[pop[,8]==1,,drop=FALSE]
adult = alive[alive[,4]!=0,,drop=FALSE]
adult_f = adult[adult[,5]==0,,drop=FALSE]
adult_m = adult[adult[,5]==1,,drop=FALSE]
NE[1,5] = nrow(adult)                   #grab n alive adults
NE[1,6] = nrow(adult_f)                 #grab n possible moms
NE[1,7] = nrow(adult_m)                 #grab n possible dads
NE[1,8] = 0                             #grab number of migrant parents
NE[1,9] = r                             #parameter number
NE[1,10] = rr                           #replicate number
NE[1,11] = prj                          #defined project
NE[1,12] = grp                          #defined group
remove(alive, adult, adult_f, adult_m)  #clean up
if(isTRUE(y == 1 && r == 1 && rr == 1)){
write.table(NE, paste(directory, "/Output/Ne_counts.csv", sep=""), sep=",", col.names=TRUE, append=FALSE, quote=FALSE, row.names=FALSE) #create new table for this sim
}else{
write.table(NE, paste(directory, "/Output/Ne_counts.csv", sep=""), sep=",", col.names=FALSE, append=TRUE, quote=FALSE, row.names=FALSE) #add to previous table
}
}
}
pop = AgeDeath(pop, maxage, y)          #kill indv based on age
if(sum(pop[,8]) <= 10){                 #if there are <=10 indv, crash pop
print(paste("CRASH @ AgeDeath - Population low, less than 10 indv"))
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp) #remember to feed same thing to all Analyze functions!
FINAL = rbind(FINAL, out[1,])
break
}
print(paste("DONE!", y, "param", r, "rep", rr))   #for tracking which sim run you're on
#clean up by removing dead indv every 25 years, this will speed up computation time
if(is.wholenumber(y/25)==TRUE){
print(paste("Cleaning up dead!"))
dead <- pop[pop[,8]==0,,drop=FALSE]
deadindv <- dead[, c(1:sz_col)]  #remove indv genotypes, will speed up computation time
if(y==25){
write.table(deadindv, paste(directory, "/Output/dead.csv", sep=""), sep=",", col.names=FALSE, append=FALSE, quote=FALSE, row.names=FALSE) #create new dead for this parameter set
}else{
write.table(deadindv, paste(directory, "/Output/dead.csv", sep=""), sep=",", col.names=FALSE, append=TRUE, quote=FALSE, row.names=FALSE)  #add to previously made table
}
pop <- pop[pop[,8]==1,,drop=FALSE] #make new pop object with only alive indv
remove(dead, deadindv) #clean up
}
#REMOVE##pop <- pop[pop[,8]==1,, drop=FALSE] #remove dead indv -- use this if don't need to hold dead indv above and not using RepSucc.R -- this will speed it up!!
}
if(y == 0){
K = k
}
#analyze each replicate
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
Analyze = function(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp){  #should this be parameters or replicates?
#get variables for run -- I think this can be copied from RunModel.R
k             = parameters$k[r]
#REMOVED###allele        = parameters$allele[r]
nSNP          = parameters$nSNP[r]
miggy         = parameters$miggy[r]
LBhet         = parameters$LBhet[r]
LBp           = parameters$LBp[r]
#REMOVED###nMicro        = parameters$nMicro[r]
#REMOVED###sex           = parameters$sex[r]
maxage        = parameters$maxage[r]
broodsize     = parameters$broodsize[r]
#REMOVED###sexratio      = parameters$sexratio[r]
maturity      = parameters$maturity[r]
years         = parameters$years[r]
r0            = parameters$r0[r]
#REMOVED###ratemort      = parameters$ratemort[r]
nSNP.mig      = parameters$nSNP.mig[r]
nSNP.cons     = parameters$nSNP.cons[r]                  #number of conserved alleles
#writeout final POP == compare this to the final pop in Cover.R, should be the same
#write.table(pop, paste(directory, "/Output/WriteOutPop.csv", sep=""), sep=",", col.names=T, row.names=F) #since in RunModel, might not need to feed it pop
#check for indv ID numbers
if(!length(pop[,1])==length(unique(pop[,1]))){ #notice that ! means NOT
print(r)
print("NON UNIQUE ID NUMBERS")
return()
}
#if no indv, exit
if(length(pop[,1])==0){return()}
#SHOULD THESE BE ALL INDV OR ONLY ALIVE??
#separate out alive indv
alive = pop[pop[,8]==1, , drop=FALSE]
###could also use: pop = pop[pop[,8]!=0, , drop=FALSE]
#calculate summary stats for final pop
FIN = matrix(nrow=years+1, ncol=20)
colnames(FIN) = c("year", "popsize", "propmig", "He", "Ho", "Fis", "nadults", "sxratio", "nmig", "Fst", "replicate", "parameterset", "numboff", "FstVSource", "FisVSource", "deltaK", "propMigSNPs", "Ho_allSNPs", "project", "group")
#note that because this is for all years of the simulation, the initialized pop is not included in this (e.g., year 0)
#add year to summary matrix
#FIN[,1] = c(0:nrow(FIN))
f = 1
#for(f in 1:nrow(FIN)){
#year = FIN[f,1] #-1 #doing this cuz also taking year 0 -- note that on 5/2/22 there were still errors with numbering on column 1
FIN[f,1] <- y
FIN[f,16] <- K
#separate out alive in current year -- Janna did these from year born and year died column
data = alive[alive[,8]>0, , drop = FALSE]
x=NULL
x = try(length(data[,1]), silent=TRUE)
if(is.null(x)){break}
if(x<1){break}
if(!is.numeric(x)){break}
#number of indv
FIN[f,2] = nrow(data)
#proportion migrants in population
FIN[f,3] =  sum(data[,2]==-1)/length(data[,1])   #1 - sum(data[,2]==-1)/length(data[,1])
#proportion of migrant genotypes in population
FIN[f,17] <- mean(data[,12])
#He and Ho - neutral (?)
SNPS = (nSNP*2) + (nSNP.mig*2) + (nSNP.cons*2)
genotype = data[, -c(ncol(data)-SNPS:ncol(data))] #THERE IS AN ERROR HERE THAT IS CHANGING THE ORDER OF COLUMNS?? ALSO NOTE THAT THE NUMBER OF SNPS IS WRONG--PROBS CUZ OF NOT RUNNING THE DIFFERENT TYPES IN RUNMODEL. FIX THIS~!
#snps = rep(c(1,2),ncol(genotype)/2)
HE = NULL
HO = NULL
loc.pos = seq(1, SNPS, 2)
for(lp in loc.pos){
#per locus heterozygostiy
locus <- genotype[, c(lp, lp+1), drop=FALSE]
#NOTE this includes MigSNPS while the other het value does not
geno  <- length(locus[,1])
het   <- length(which(locus[,1] != locus[,2]))
het.observed <- het/geno
HO = c(HO, het.observed)
freqs <- table(locus)
homozygous = NULL
for(v in 1:length(freqs)){
homozygous = c(homozygous, (freqs[v]/sum(freqs)*freqs[v]/sum(freqs)))
}
het.expected <- 1 - sum(homozygous)
HE = c(HE, het.expected)
}
FIN[f,4] <- mean(HE)
FIN[f,5] <- mean(data[,11])
FIN[f,18] <- mean(HO)
#find number of adults per year
adults = data[data[,4]>= maturity, , drop = FALSE]
FIN[f,7] = nrow(adults)
########################################NEW####################################3
#find the sex ratio
FIN[f,8] = mean(data[,'sex']) #<0.5 female, >.5 male
#note this includes babies
#note number of migrants
if(y != 0){
FIN[f,9] = mig  #generated in Migrate.R, passed to RunModel.R, and passed here in Analyze.R
}else{
FIN[f,9] = 0  #this is for year 0, there are no migrants in this pop
}
#calc the proportion of migrant alleles in the population
#do I want heterozygosity of mig alleles? or freq of mig alleles? or something different?
#?
#?
#?
#table function https://www.datasciencemadesimple.com/table-function-in-r/#:~:text=Table%20function%20in%20R%20-table%20%28%29%2C%20performs%20categorical,creating%20Frequency%20tables%20with%20condition%20and%20cross%20tabulations.
#LINKS FOR CALC FST USING HIERFSTAT
#https://rdrr.io/cran/hierfstat/
#https://rdrr.io/cran/hierfstat/#vignettes
#https://rdrr.io/cran/hierfstat/man/biall2dos.html
#https://rdrr.io/cran/hierfstat/man/fs.dosage.html
#https://rdrr.io/cran/hierfstat/man/fstat2dos.html
#https://rdrr.io/cran/hierfstat/man/nb.alleles.html
#https://rdrr.io/cran/hierfstat/man/pairwise.neifst.html
#https://rdrr.io/cran/hierfstat/man/pairwise.WCfst.html
#https://rdrr.io/cran/hierfstat/man/ppfst.html
#prepare the genotypes for hierfstat
SNPS = (nSNP*2) + (nSNP.mig*2) + (nSNP.cons*2)                    #find number of SNPs
fstdata <- data[, -c(ncol(data)-(SNPS):ncol(data))]               #grab SNPs
#change 0s to 2s for hierfstat to read
fstdata[fstdata[,]==0] <-2
#merge pos1 and pos2 into pos1, then remove pos2
fstdata[,pos1] <- as.numeric(paste(fstdata[,pos1], fstdata[,pos2], sep=""))
fstdata <- fstdata[,-c(pos2)]
#add pop identifier for calculations
popident <- matrix(nrow=nrow(fstdata), ncol=1)
popident[,1] = y
fstdata <- cbind(popident,fstdata)
if(y != 0){
#do the same to the initialized focal pop -- for comparison
#MOVEDTORUNMODEL##fstinit <- focalpop[, -c(ncol(focalpop)-(SNPS):ncol(focalpop))]               #grab SNPs
#MOVEDTORUNMODEL##fstinit[fstinit[,]==0] <-2                                                    #change 0s to 2s
#MOVEDTORUNMODEL##fstinit[,pos1] <- as.numeric(paste(fstinit[,pos1], fstinit[,pos2], sep=""))                     #merge SNPs
#MOVEDTORUNMODEL##fstinit <- fstinit[,-c(pos2)]                                                 #remove single pos2 SNPs
#MOVEDTORUNMODEL##initident <- matrix(nrow=nrow(fstinit), ncol=1)                               #add pop identifier
#MOVEDTORUNMODEL##initident[,1] = 0
#MOVEDTORUNMODEL##fstinit <- cbind(initident,fstinit)                                           #merge identifier and genotypes
fstnow <- rbind(fstdata, fstinit)                                            #merge current year and initialized year to one matrix for calculations
fstnow <- as.data.frame(fstnow)                                               #turn into a dataframe
calc <-wc(fstnow, diploid=TRUE, pol=0)                                         #calc FST and FIS
#calc <- pairwise.WCfst(fstdata,diploid=TRUE)                                   #calculate FST
FIN[f,10] <- calc$FST
FIN[f,6] <- calc$FIS
#do the same to the initialized source pop -- for comparison
#MOVEDTORUNMODEL##fstsource <- source1[, -c(ncol(source1)-(SNPS):ncol(source1))]                    #grab SNPs
#MOVEDTORUNMODEL##fstsource[fstsource[,]==0] <-2                                                    #change 0s to 2s
#MOVEDTORUNMODEL##fstsource[,pos1] <- as.numeric(paste(fstsource[,pos1], fstsource[,pos2], sep=""))                     #merge SNPs
#MOVEDTORUNMODEL##fstsource <- fstsource[,-c(pos2)]                                                 #remove single pos2 SNPs
#MOVEDTORUNMODEL##sourceident <- matrix(nrow=nrow(fstsource), ncol=1)                               #add pop identifier
#MOVEDTORUNMODEL##sourceident[,1] = -1
#MOVEDTORUNMODEL##fstsource <- cbind(sourceident,fstsource)                                         #merge identifier and genotypes
fstdatavsource <- rbind(fstdata, fstsource)                                              #merge current year and initialized year to one matrix for calculations
fstdatavsource <- as.data.frame(fstdatavsource)
calcvsource <-wc(fstdatavsource, diploid=TRUE, pol=0)
FIN[f,14] <- calcvsource$FST
#FIN[f,15] <- calcvsource$FIS
}
if(y == 0){
#do the same to the initialized source pop -- for comparison
#MOVEDTORUNMODEL##fstsource <- source1[, -c(ncol(source1)-(SNPS):ncol(source1))]                    #grab SNPs
#MOVEDTORUNMODEL##fstsource[fstsource[,]==0] <-2                                                    #change 0s to 2s
#MOVEDTORUNMODEL##fstsource[,pos1] <- as.numeric(paste(fstsource[,pos1], fstsource[,pos2], sep=""))                     #merge SNPs
#MOVEDTORUNMODEL##fstsource <- fstsource[,-c(pos2)]                                                 #remove single pos2 SNPs
#MOVEDTORUNMODEL##sourceident <- matrix(nrow=nrow(fstsource), ncol=1)                               #add pop identifier
#MOVEDTORUNMODEL##sourceident[,1] = -1
#MOVEDTORUNMODEL##fstsource <- cbind(sourceident,fstsource)                                         #merge identifier and genotypes
fstyo <- rbind(fstinit, fstsource) #merge current year and initialized year to one matrix for calculations
fstyo <- as.data.frame(fstyo)                                               #turn into a dataframe
calcyo <-wc(fstyo, diploid=TRUE, pol=0)                                         #calc FST and FIS
FIN[f,10] <- 0 #no divergence at y=0
FIN[f,6] <- 0  #no inbreeding at y=0
FIN[f,14] <- calcyo$FST
FIN[f,15] <- calcyo$FIS
remove(fstyo)
}
FIN[f,11] = rr   #add replicate number
FIN[f,12] = r    #add parameter set number
if(y == 0){
numboff = 0
}
FIN[f,13] = numboff
FIN[f,19] = prj
FIN[f,20] = grp
#Fis for this pop
#NOTES 4/18/22 -- consider another pairwise measure tha tmay work rather than FST. potentially the number of unique alleles??
#this could be because FST is not sensitive to minor changes because the scale is in evolutionary time
#may also want to add the number of variable SNPS (across indvs) since heterozy is within an indv
#ALSO add from meeting 4/18/22
#year 0 should be in this table >> look at the photo I took to see how to do this. in short, will want to ski[ to analyze in year 0 and then go through all timesteps]
#that way, year 0 will be in the same tbale and iwll make it easier to analyze for following years
#ALSO will want to add SNPs that are the SAME between pop and source so that we can seperate mutation, migration, and drift forces. think about this more.
#}
params = parameters[rep(r, nrow(FIN)),]
out = cbind(FIN,params)
colnames(out) = c("year", "popsize", "propmig", "He", "Ho", "Fis", "nadults", "sxratio", "nmig", "Fst", "replicate", "parameterset", "numboff", "FstVSource", "FisVSource", "deltaK", "propMigSNPs", "Ho_allSNPs", "project", "group",
"k", "nSNP", "miggy", "LBhet", "LBp", "maxage", "broodsize", "maturity", "years", "r0", "nSNP.mig", "nSNP.cons")
remove(alive, adults, data, FIN, fstdata, genotype, locus, params, popident,
freqs, geno, HE, het, het.expected, het.observed, HO, homozygous, loc.pos)
return(out)
}
#analyze each replicate
out = Analyze(parameters, r, pop, mig, fstinit, fstsource, y, rr, nSNP, nSNP.mig, nSNP.cons, numboff, K, pos1, pos2, prj, grp)
MateChoice = function(pop, sex, maturity){ #allee, matemigs
pop = pop[which(pop[,1]%NOTin%dead), , drop=FALSE]
immature  = pop[pop[,2 < 13, ,drop=FALSE]          #remove immature indvs
#find which sex has more, male or female.
ck = mean(pop[,'sex']) #<0.5 female, >.5 male
print(paste("the sex ratio is", ck))
if(ck == 1){
return()   ##ERROR HERE BECAUSE BREAK/NEXT ARENT IN A LOOP (if is not a loop)
}else if(ck == 0){
return() #break #next
}else{
# Set your desired ratio of males to females
male_ratio <- 0.3  # this would be a 30% males 70% females ratio which is what is found in the literature
# set parameters
#Calculate the number of males and females based on the desired ratio
num_males <- round(k * male_ratio) # It ensures that the result is a whole number.
num_females <- (k - num_males)
num_females <- 100  # Number of females
# Create a dataset representing individuals with age information
# Create the initial data frame
set.seed(123)  # Set a seed for reproducibility
num_individuals = popsize
mate <- data.frame(
ID = 1:num_individuals,
sex = sample(c(0,1), size= num_individuals, replace = TRUE),
age = sample(maturity:maxage, num_individuals, replace = TRUE),  # Assuming age ranges from 2 to 13, that the maturity and  max age respectively.
breed_perc = rep(0, num_individuals)  # Initialize breeding percentage to 0
)
# Step 2: Define rules for breeding percentage based on age
breed_rules <- function(pop, maxage, maturity, sex) {
if (sex == "male") {
return(0)  # Males do not contribute to breeding
} else {
# Define rules for females, e.g., increase breeding percentage with age
# You can customize this function based on your specific requirements
return(age * 5)  # Example: Breeding percentage increases by age * 5
}
}
# Step 3: Loop through ages and update breeding percentages
for(age in unique(pop$age)) {
for (sex in c("male", "female")) {
subset_df <- pop[pop$age == age & pop$sex == sex, ]
if (nrow(subset_df) > 0) {
breeding_pct <- breeding_rules(age, sex)
pop[pop$age == age & pop$sex == sex, "breeding_percentage"] <- breeding_pct
}
}
}
# Step 4: Simulate breeding for each age group
for (age in unique(pop$age)) {
males <- pop$ID[pop$age == age & pop$sex == "male"]
females <- pop$ID[pop$age == age & pop$sex == "female"]
# Perform breeding simulation (e.g., using sample())
# You can customize this step based on your breeding algorithm
# For example: randomly select pairs of males and females to breed
# Update the breeding percentage in the data frame accordingly
}
# Initialize vectors to track mating pairs
mating_pairs <- data.frame(MaleID = integer(0), FemaleID = integer(0)) #the mating_pairs data frame is initially empty, with two columns, MaleID and FemaleID, both of which are expected to contain integer values.
# Simulate the mating process for multiple generations
for (gen in 1:num_generations) {
# Select males to mate based on age and probabilities
selected_males <- sample(males$ID, size = length(females$ID), prob = mating_prob, replace = TRUE)
# Create mating pairs
mating_pairs_gen <- data.frame(MaleID = selected_males, FemaleID = females$ID)
# Append mating pairs to the overall list
mating_pairs <- rbind(mating_pairs, mating_pairs_gen)
# Simulate mating and producing offspring
offspring_sex <- sample(0:1, size = 1)  # Randomly assign offspring's sex
offspring[[mating_pairs]] <- c(offspring[[mating_pairs]], offspring_sex)
return(offspring)
}
# Step 1: Create the initial data frame
set.seed(123)  # Set a seed for reproducibility
num_individuals <- 100
pop <- data.frame(
ID = 1:num_individuals,
sex = sample(c("male", "female"), num_individuals, replace = TRUE),
age = sample(1:10, num_individuals, replace = TRUE),  # Assuming age ranges from 1 to 10
breeding_percentage = rep(0, num_individuals)  # Initialize breeding percentage to 0
)
# Step 2: Define rules for breeding percentage based on age
breeding_rules <- function(age, sex) {
if (sex == "male") {
return(0)  # Males do not contribute to breeding
} else {
# Define rules for females, e.g., increase breeding percentage with age
# You can customize this function based on your specific requirements
return(age * 5)  # Example: Breeding percentage increases by age * 5
}
}
# Step 3: Loop through ages and update breeding percentages
for(age in unique(pop$age)) {
for (sex in c("male", "female")) {
subset_df <- pop[pop$age == age & pop$sex == sex, ]
if (nrow(subset_df) > 0) {
breeding_pct <- breeding_rules(age, sex)
pop[pop$age == age & pop$sex == sex, "breeding_percentage"] <- breeding_pct
}
}
}
# Step 4: Simulate breeding for each age group
for (age in unique(pop$age)) {
males <- pop$ID[pop$age == age & pop$sex == "male"]
females <- pop$ID[pop$age == age & pop$sex == "female"]
# Perform breeding simulation (e.g., using sample())
# You can customize this step based on your breeding algorithm
# For example: randomly select pairs of males and females to breed
# Update the breeding percentage in the data frame accordingly
}
